{"version":3,"sources":["syncplay.min.js","index.js","ArrayHandlers.js","EventEmitter.js","Protocol.js","Player.js","Client.js","WebSocketProtocol.js","export.js"],"names":["_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","prototype","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","TypeError","create","constructor","value","setPrototypeOf","__proto__","_classCallCheck","instance","SyncPlay","ArrayHandlers","get","content","array","find","itemFound","name","includes","remove","index","splice","EventEmitter","this","eventList","activeEvents","callback","push","_this","on","modifiedCallback","data","removeListener","_i","indexOf","Protocol","_EventEmitter","_this2","getPrototypeOf","Player","staticProtocolList","staticPlayerProxyList","Client","_EventEmitter2","_this3","protocolList","playerList","playerProxyList","state","protocol","player","playerProxy","options","_this4","Error","fetchedProtocol","getProtocol","undefined","currentProtocol","proxyEvents","event","currentPlayer","command","url","supports","proxyCommand","foundPlayer","WebSocketProtocol","_SyncPlay$Protocol","_this6","socket","WebSocket","addEventListener","emit","_command","window"],"mappings":"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","file":"syncplay.min.js","sourcesContent":["(function() {\n\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/* eslint-disable no-unused-vars */\nvar SyncPlay = {};\nSyncPlay.util = {};\nvar ArrayHandlers = {\n\tget: function get(array, content) {\n\t\tif (typeof content == \"string\") {\n\t\t\treturn array.find(function (itemFound) {\n\t\t\t\treturn itemFound.name == content;\n\t\t\t});\n\t\t} else {\n\t\t\tif (array.includes(content)) {\n\t\t\t\treturn content;\n\t\t\t} else {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\t},\n\tremove: function remove(array, content) {\n\t\tvar index = void 0;\n\t\tif (typeof content == \"string\") {\n\t\t\tindex = array.findIndex(function (itemFound) {\n\t\t\t\treturn itemFound.name == content;\n\t\t\t});\n\t\t} else {\n\t\t\tindex = array.indexOf(content);\n\t\t}\n\t\tif (index > -1) array.splice(index, 1);\n\t}\n};\n\nSyncPlay.util.ArrayHandlers = ArrayHandlers;\n\nvar EventEmitter = function () {\n\tfunction EventEmitter() {\n\t\t_classCallCheck(this, EventEmitter);\n\n\t\tthis.eventList = {};\n\t\tthis.activeEvents = true;\n\t}\n\n\t_createClass(EventEmitter, [{\n\t\tkey: \"on\",\n\t\tvalue: function on(name, callback) {\n\t\t\tif (this.eventList[name] == null) {\n\t\t\t\tthis.eventList[name] = [];\n\t\t\t}\n\t\t\tthis.eventList[name].push(callback);\n\t\t}\n\t}, {\n\t\tkey: \"once\",\n\t\tvalue: function once(name, callback) {\n\t\t\tvar _this = this;\n\n\t\t\tvar modifiedCallback = function modifiedCallback(data) {\n\t\t\t\tcallback(data);\n\t\t\t\t_this.removeListener(name, modifiedCallback);\n\t\t\t};\n\t\t\tthis.on(name, modifiedCallback);\n\t\t}\n\t}, {\n\t\tkey: \"any\",\n\t\tvalue: function any(callback) {\n\t\t\tthis.on(\"*\", callback);\n\t\t}\n\t}, {\n\t\tkey: \"emit\",\n\t\tvalue: function emit(name, data) {\n\t\t\tif (!this.activeEvents) return 0;\n\t\t\tif (!this.eventList[name]) return 0;\n\n\t\t\tfor (var i = 0; i < this.eventList[name].length; i++) {\n\t\t\t\tthis.eventList[name](data);\n\t\t\t}\n\n\t\t\tif (this.eventList[\"*\"] && this.eventList[\"*\"].length > 0) {\n\t\t\t\tfor (var _i = 0; _i < this.eventList[\"*\"].length; _i++) {\n\t\t\t\t\tthis.eventList[\"*\"](data);\n\t\t\t\t}\n\t\t\t\treturn this.eventList[name].length + this.eventList[\"*\"].length;\n\t\t\t} else {\n\t\t\t\treturn this.eventList[name].length;\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"removeListener\",\n\t\tvalue: function removeListener(name, callback) {\n\t\t\t// TODO: find a way to gracefully report problems like this\n\t\t\tif (!this.eventList[name]) return;\n\n\t\t\tvar index = this.eventList[name].indexOf(callback);\n\t\t\tif (index > -1) this.eventList.splice(index, 1);\n\t\t}\n\t}]);\n\n\treturn EventEmitter;\n}();\n\nSyncPlay.util.EventEmitter = EventEmitter;\n/* global EventEmitter */\n\nvar Protocol = function (_EventEmitter) {\n\t_inherits(Protocol, _EventEmitter);\n\n\tfunction Protocol(name) {\n\t\t_classCallCheck(this, Protocol);\n\n\t\tvar _this2 = _possibleConstructorReturn(this, (Protocol.__proto__ || Object.getPrototypeOf(Protocol)).call(this));\n\n\t\t_this2.name = name;\n\t\treturn _this2;\n\t}\n\n\treturn Protocol;\n}(EventEmitter);\n\nSyncPlay.Protocol = Protocol;\n\nvar Player = function Player(name) {\n\t_classCallCheck(this, Player);\n\n\tthis.name = name;\n};\n\nSyncPlay.Player = Player;\n/* global EventEmitter, ArrayHandlers */\n\nvar staticProtocolList = [];\nvar staticPlayerProxyList = [];\n\nvar Client = function (_EventEmitter2) {\n\t_inherits(Client, _EventEmitter2);\n\n\tfunction Client() {\n\t\t_classCallCheck(this, Client);\n\n\t\tvar _this3 = _possibleConstructorReturn(this, (Client.__proto__ || Object.getPrototypeOf(Client)).call(this));\n\n\t\t_this3.protocolList = staticProtocolList;\n\t\t_this3.playerList = [];\n\t\t_this3.playerProxyList = staticPlayerProxyList;\n\t\t_this3.state = 0;\n\t\treturn _this3;\n\t}\n\n\t_createClass(Client, [{\n\t\tkey: \"addProtocol\",\n\t\tvalue: function addProtocol(protocol) {\n\t\t\tthis.protocolList.push(protocol);\n\t\t}\n\t}, {\n\t\tkey: \"getProtocol\",\n\t\tvalue: function getProtocol(protocol) {\n\t\t\treturn ArrayHandlers.get(this.protocolList, protocol);\n\t\t}\n\t}, {\n\t\tkey: \"removeProtocol\",\n\t\tvalue: function removeProtocol(protocol) {\n\t\t\tArrayHandlers.remove(this.protocolList, protocol);\n\t\t}\n\t}, {\n\t\tkey: \"addPlayer\",\n\t\tvalue: function addPlayer(player) {\n\t\t\tthis.playerList.push(player);\n\t\t}\n\t}, {\n\t\tkey: \"getPlayer\",\n\t\tvalue: function getPlayer(player) {\n\t\t\treturn ArrayHandlers.get(this.playerList, player);\n\t\t}\n\t}, {\n\t\tkey: \"removePlayer\",\n\t\tvalue: function removePlayer(player) {\n\t\t\tArrayHandlers.remove(this.playerList, player);\n\t\t}\n\t}, {\n\t\tkey: \"addPlayerProxy\",\n\t\tvalue: function addPlayerProxy(playerProxy) {\n\t\t\tthis.playerProxyList.push(playerProxy);\n\t\t}\n\t}, {\n\t\tkey: \"getPlayerProxy\",\n\t\tvalue: function getPlayerProxy(playerProxy) {\n\t\t\treturn ArrayHandlers.get(this.playerProxyList, playerProxy);\n\t\t}\n\t}, {\n\t\tkey: \"removePlayerProxy\",\n\t\tvalue: function removePlayerProxy(playerProxy) {\n\t\t\tArrayHandlers.remove(this.playerProxyList, playerProxy);\n\t\t}\n\t}, {\n\t\tkey: \"connect\",\n\t\tvalue: function connect(protocol, options) {\n\t\t\tvar _this4 = this;\n\n\t\t\tif (this.state != 0) {\n\t\t\t\tthrow new Error(\"Client is currently connected, must disconnect first before reconnecting.\");\n\t\t\t}\n\n\t\t\tvar fetchedProtocol = this.getProtocol(protocol);\n\t\t\tif (fetchedProtocol == undefined || !fetchedProtocol) {\n\t\t\t\tthrow new Error(\"No protocol of that name is loaded!\");\n\t\t\t}\n\n\t\t\tthis.currentProtocol = fetchedProtocol;\n\t\t\tthis.state = 1;\n\n\t\t\tthis.proxyEvents(\"connecting\", protocol);\n\t\t\tfetchedProtocol.any(this.proxyEvents);\n\t\t\tfetchedProtocol.on(\"seturl\", this.setURL);\n\n\t\t\t// TODO: implement some sort of log system, for errors, connection progress etc.\n\n\t\t\tfetchedProtocol.connect(options, function () {\n\t\t\t\tif (_this4.state != 1) {\n\t\t\t\t\treturn; // ignore event if not in connecting state\n\t\t\t\t}\n\t\t\t\t_this4.state = 2;\n\t\t\t\t_this4.proxyEvents(\"connected\");\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: \"proxyEvents\",\n\t\tvalue: function proxyEvents(event, data) {\n\t\t\tfor (var i = 0; i < this.playerProxyList; i++) {\n\t\t\t\tthis.playerProxyList[i].on(event, data);\n\t\t\t}\n\t\t\tif (this.currentPlayer) {\n\t\t\t\t// players must not respond to seturl\n\t\t\t\tthis.currentPlayer.on(event, data);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"proxyCommand\",\n\t\tvalue: function proxyCommand(command, data) {\n\t\t\tif (this.currentPlayer) {\n\t\t\t\tfor (var i = 0; i < this.playerProxyList; i++) {\n\t\t\t\t\tthis.playerProxyList[i].command(command, data);\n\t\t\t\t}\n\t\t\t\tthis.currentPlayer.command(command, data);\n\t\t\t} else {\n\t\t\t\t// TODO: maybe error if problematic?\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"proxyCommandToProtocol\",\n\t\tvalue: function proxyCommandToProtocol(command, data) {\n\t\t\t// TODO: Should players emit (and have proxied) events?\n\t\t\tif (this.currentPlayer) {\n\t\t\t\tfor (var i = 0; i < this.playerProxyList; i++) {\n\t\t\t\t\tthis.playerProxyList[i].command(command, data);\n\t\t\t\t}\n\t\t\t\tthis.currentProtocol.command(command, data);\n\t\t\t} else {\n\t\t\t\t// TODO: maybe error if problematic?\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"setURL\",\n\t\tvalue: function setURL(url) {\n\t\t\tif (this.currentPlayer) {\n\t\t\t\t// TODO: what happens when a http player\n\t\t\t\t//       and yt player coexist? how do\n\t\t\t\t//       we choose which to use?\n\t\t\t\tif (this.currentPlayer.supports(url)) {\n\t\t\t\t\tthis.proxyCommand(\"seturl\", url);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar foundPlayer = this.playerList.find(function (player) {\n\t\t\t\treturn player.supports(url);\n\t\t\t});\n\t\t\tif (foundPlayer) {\n\t\t\t\t// if player is found, switch to it\n\t\t\t\tthis.currentPlayer.command(\"terminate\");\n\t\t\t\tthis.currentPlayer = foundPlayer;\n\t\t\t\tthis.proxyCommand(\"seturl\", url);\n\t\t\t} else {\n\t\t\t\t// TODO: handle no players to play url\n\t\t\t\t//       catch-all player?\n\t\t\t\tthrow new Error(\"No players to handle URL available\");\n\t\t\t}\n\t\t}\n\t}], [{\n\t\tkey: \"addStaticProtocol\",\n\t\tvalue: function addStaticProtocol(protocol) {\n\t\t\tstaticProtocolList.push(protocol);\n\t\t}\n\t}, {\n\t\tkey: \"getStaticProtocol\",\n\t\tvalue: function getStaticProtocol(protocol) {\n\t\t\treturn ArrayHandlers.get(staticProtocolList, protocol);\n\t\t}\n\t}, {\n\t\tkey: \"removeStaticProtocol\",\n\t\tvalue: function removeStaticProtocol(protocol) {\n\t\t\tArrayHandlers.remove(staticProtocolList, protocol);\n\t\t}\n\t}, {\n\t\tkey: \"addStaticPlayerProxy\",\n\t\tvalue: function addStaticPlayerProxy(playerProxy) {\n\t\t\tstaticPlayerProxyList.push(playerProxy);\n\t\t}\n\t}, {\n\t\tkey: \"getStaticPlayerProxy\",\n\t\tvalue: function getStaticPlayerProxy(playerProxy) {\n\t\t\treturn ArrayHandlers.get(staticPlayerProxyList, playerProxy);\n\t\t}\n\t}, {\n\t\tkey: \"removeStaticPlayerProxy\",\n\t\tvalue: function removeStaticPlayerProxy(playerProxy) {\n\t\t\tArrayHandlers.remove(staticPlayerProxyList, playerProxy);\n\t\t}\n\t}]);\n\n\treturn Client;\n}(EventEmitter);\n\nSyncPlay.Client = Client;\n\nvar WebSocketProtocol = function (_SyncPlay$Protocol) {\n\t_inherits(WebSocketProtocol, _SyncPlay$Protocol);\n\n\tfunction WebSocketProtocol() {\n\t\t_classCallCheck(this, WebSocketProtocol);\n\n\t\treturn _possibleConstructorReturn(this, (WebSocketProtocol.__proto__ || Object.getPrototypeOf(WebSocketProtocol)).call(this, \"WebSocket-builtin\"));\n\t}\n\n\t_createClass(WebSocketProtocol, [{\n\t\tkey: \"connect\",\n\t\tvalue: function connect(options, callback) {\n\t\t\tvar _this6 = this;\n\n\t\t\tthis.socket = new WebSocket(options.url);\n\n\t\t\tthis.socket.addEventListener(\"open\", function () {\n\t\t\t\tcallback();\n\t\t\t});\n\n\t\t\tthis.socket.addEventListener(\"message\", function (data) {\n\t\t\t\t_this6.emit(\"message\", data);\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: \"command\",\n\t\tvalue: function command(_command, data) {\n\t\t\t_command;\n\t\t\tdata;\n\t\t}\n\t}]);\n\n\treturn WebSocketProtocol;\n}(SyncPlay.Protocol);\n\n// Adds the protocol to SyncPlay statically, so every Client has it\n\n\nSyncPlay.Client.addStaticProtocol(new WebSocketProtocol());\nwindow.SyncPlay = SyncPlay;\n}());\n","/* eslint-disable no-unused-vars */\r\nlet SyncPlay = {};\r\nSyncPlay.util = {};","let ArrayHandlers = {\r\n\tget(array, content) {\r\n\t\tif (typeof content == \"string\") {\r\n\t\t\treturn array.find((itemFound) => {\r\n\t\t\t\treturn itemFound.name == content;\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\tif (array.includes(content)) {\r\n\t\t\t\treturn content;\r\n\t\t\t} else {\r\n\t\t\t\treturn undefined;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tremove(array, content) {\r\n\t\tlet index;\r\n\t\tif (typeof content == \"string\") {\r\n\t\t\tindex = array.findIndex((itemFound) => {\r\n\t\t\t\treturn itemFound.name == content;\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\tindex = array.indexOf(content);\r\n\t\t}\r\n\t\tif (index > -1) array.splice(index, 1);\r\n\t}\r\n};\r\n\r\nSyncPlay.util.ArrayHandlers = ArrayHandlers;","class EventEmitter {\r\n\tconstructor() {\r\n\t\tthis.eventList = {};\r\n\t\tthis.activeEvents = true;\r\n\t}\r\n\r\n\ton(name, callback) {\r\n\t\tif (this.eventList[name] == null) {\r\n\t\t\tthis.eventList[name] = [];\r\n\t\t}\r\n\t\tthis.eventList[name].push(callback);\r\n\t}\r\n\r\n\tonce(name, callback) {\r\n\t\tlet modifiedCallback = (data) => {\r\n\t\t\tcallback(data);\r\n\t\t\tthis.removeListener(name, modifiedCallback);\r\n\t\t};\r\n\t\tthis.on(name, modifiedCallback);\r\n\t}\r\n\r\n\tany(callback) {\r\n\t\tthis.on(\"*\", callback);\r\n\t}\r\n\r\n\temit(name, data) {\r\n\t\tif (!this.activeEvents) return 0;\r\n\t\tif (!this.eventList[name]) return 0;\r\n\t\t\r\n\t\tfor (let i = 0; i < this.eventList[name].length; i++) {\r\n\t\t\tthis.eventList[name](data);\r\n\t\t}\r\n\r\n\t\tif (this.eventList[\"*\"] && this.eventList[\"*\"].length > 0) {\r\n\t\t\tfor (let i = 0; i < this.eventList[\"*\"].length; i++) {\r\n\t\t\t\tthis.eventList[\"*\"](data);\r\n\t\t\t}\r\n\t\t\treturn this.eventList[name].length + this.eventList[\"*\"].length;\r\n\t\t} else {\r\n\t\t\treturn this.eventList[name].length;\r\n\t\t}\r\n\t}\r\n\r\n\tremoveListener(name, callback) {\r\n\t\t// TODO: find a way to gracefully report problems like this\r\n\t\tif (!this.eventList[name]) return;\r\n\r\n\t\tlet index = this.eventList[name].indexOf(callback);\r\n\t\tif (index > -1) this.eventList.splice(index, 1);\r\n\t}\r\n}\r\n\r\nSyncPlay.util.EventEmitter = EventEmitter;","/* global EventEmitter */\r\n\r\nclass Protocol extends EventEmitter {\r\n\tconstructor(name) {\r\n\t\tsuper();\r\n\t\tthis.name = name;\r\n\t}\r\n}\r\n\r\nSyncPlay.Protocol = Protocol;","class Player {\r\n\tconstructor(name) {\r\n\t\tthis.name = name;\r\n\t}\r\n}\r\n\r\nSyncPlay.Player = Player;","/* global EventEmitter, ArrayHandlers */\r\n\r\nlet staticProtocolList = [];\r\nlet staticPlayerProxyList = [];\r\n\r\nclass Client extends EventEmitter {\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.protocolList = staticProtocolList;\r\n\t\tthis.playerList = [];\r\n\t\tthis.playerProxyList = staticPlayerProxyList;\r\n\t\tthis.state = 0;\r\n\t}\r\n\r\n\taddProtocol(protocol) {\r\n\t\tthis.protocolList.push(protocol);\r\n\t}\r\n\r\n\tgetProtocol(protocol) {\r\n\t\treturn ArrayHandlers.get(this.protocolList, protocol);\r\n\t}\r\n\r\n\tremoveProtocol(protocol) {\r\n\t\tArrayHandlers.remove(this.protocolList, protocol);\r\n\t}\r\n\r\n\tstatic addStaticProtocol(protocol) {\r\n\t\tstaticProtocolList.push(protocol);\r\n\t}\r\n\r\n\tstatic getStaticProtocol(protocol) {\r\n\t\treturn ArrayHandlers.get(staticProtocolList, protocol);\r\n\t}\r\n\r\n\tstatic removeStaticProtocol(protocol) {\r\n\t\tArrayHandlers.remove(staticProtocolList, protocol);\r\n\t}\r\n\r\n\taddPlayer(player) {\r\n\t\tthis.playerList.push(player);\r\n\t}\r\n\r\n\tgetPlayer(player) {\r\n\t\treturn ArrayHandlers.get(this.playerList, player);\r\n\t}\r\n\r\n\tremovePlayer(player) {\r\n\t\tArrayHandlers.remove(this.playerList, player);\r\n\t}\r\n\r\n\taddPlayerProxy(playerProxy) {\r\n\t\tthis.playerProxyList.push(playerProxy);\r\n\t}\r\n\r\n\tgetPlayerProxy(playerProxy) {\r\n\t\treturn ArrayHandlers.get(this.playerProxyList, playerProxy);\r\n\t}\r\n\r\n\tremovePlayerProxy(playerProxy) {\r\n\t\tArrayHandlers.remove(this.playerProxyList, playerProxy);\r\n\t}\r\n\r\n\tstatic addStaticPlayerProxy(playerProxy) {\r\n\t\tstaticPlayerProxyList.push(playerProxy);\r\n\t}\r\n\r\n\tstatic getStaticPlayerProxy(playerProxy) {\r\n\t\treturn ArrayHandlers.get(staticPlayerProxyList, playerProxy);\r\n\t}\r\n\r\n\tstatic removeStaticPlayerProxy(playerProxy) {\r\n\t\tArrayHandlers.remove(staticPlayerProxyList, playerProxy);\r\n\t}\r\n\r\n\tconnect(protocol, options) {\r\n\t\tif (this.state != 0) {\r\n\t\t\tthrow new Error(\"Client is currently connected, must disconnect first before reconnecting.\");\r\n\t\t}\r\n\r\n\t\tlet fetchedProtocol = this.getProtocol(protocol);\r\n\t\tif (fetchedProtocol == undefined || !fetchedProtocol) {\r\n\t\t\tthrow new Error(\"No protocol of that name is loaded!\");\r\n\t\t}\r\n\r\n\t\tthis.currentProtocol = fetchedProtocol;\r\n\t\tthis.state = 1;\r\n\r\n\t\tthis.proxyEvents(\"connecting\", protocol);\r\n\t\tfetchedProtocol.any(this.proxyEvents);\r\n\t\tfetchedProtocol.on(\"seturl\", this.setURL);\r\n\r\n\t\t// TODO: implement some sort of log system, for errors, connection progress etc.\r\n\r\n\t\tfetchedProtocol.connect(options, () => {\r\n\t\t\tif (this.state != 1) {\r\n\t\t\t\treturn; // ignore event if not in connecting state\r\n\t\t\t}\r\n\t\t\tthis.state = 2;\r\n\t\t\tthis.proxyEvents(\"connected\");\r\n\t\t});\r\n\t}\r\n\r\n\tproxyEvents(event, data) {\r\n\t\tfor (let i = 0; i < this.playerProxyList; i++) {\r\n\t\t\tthis.playerProxyList[i].on(event, data);\r\n\t\t}\r\n\t\tif (this.currentPlayer) {\r\n\t\t\t// players must not respond to seturl\r\n\t\t\tthis.currentPlayer.on(event, data);\r\n\t\t}\r\n\t}\r\n\r\n\tproxyCommand(command, data) {\r\n\t\tif (this.currentPlayer) {\r\n\t\t\tfor (let i = 0; i < this.playerProxyList; i++) {\r\n\t\t\t\tthis.playerProxyList[i].command(command, data);\r\n\t\t\t}\r\n\t\t\tthis.currentPlayer.command(command, data);\r\n\t\t} else {\r\n\t\t\t// TODO: maybe error if problematic?\r\n\t\t}\r\n\t}\r\n\r\n\tproxyCommandToProtocol(command, data) {\r\n\t\t// TODO: Should players emit (and have proxied) events?\r\n\t\tif (this.currentPlayer) {\r\n\t\t\tfor (let i = 0; i < this.playerProxyList; i++) {\r\n\t\t\t\tthis.playerProxyList[i].command(command, data);\r\n\t\t\t}\r\n\t\t\tthis.currentProtocol.command(command, data);\r\n\t\t} else {\r\n\t\t\t// TODO: maybe error if problematic?\r\n\t\t}\r\n\t}\r\n\r\n\tsetURL(url) {\r\n\t\tif (this.currentPlayer) {\r\n\t\t\t// TODO: what happens when a http player\r\n\t\t\t//       and yt player coexist? how do\r\n\t\t\t//       we choose which to use?\r\n\t\t\tif (this.currentPlayer.supports(url)) {\r\n\t\t\t\tthis.proxyCommand(\"seturl\", url);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet foundPlayer = this.playerList.find((player) => {\r\n\t\t\treturn player.supports(url);\r\n\t\t});\r\n\t\tif (foundPlayer) {\r\n\t\t\t// if player is found, switch to it\r\n\t\t\tthis.currentPlayer.command(\"terminate\");\r\n\t\t\tthis.currentPlayer = foundPlayer;\r\n\t\t\tthis.proxyCommand(\"seturl\", url);\r\n\t\t} else {\r\n\t\t\t// TODO: handle no players to play url\r\n\t\t\t//       catch-all player?\r\n\t\t\tthrow new Error(\"No players to handle URL available\");\r\n\t\t}\r\n\t}\r\n\t\r\n}\r\n\r\nSyncPlay.Client = Client;","class WebSocketProtocol extends SyncPlay.Protocol {\r\n\tconstructor() {\r\n\t\tsuper(\"WebSocket-builtin\");\r\n\t}\r\n\r\n\tconnect(options, callback) {\r\n\t\tthis.socket = new WebSocket(options.url);\r\n\r\n\t\tthis.socket.addEventListener(\"open\", () => {\r\n\t\t\tcallback();\r\n\t\t});\r\n\r\n\t\tthis.socket.addEventListener(\"message\", (data) => {\r\n\t\t\tthis.emit(\"message\", data);\r\n\t\t});\r\n\t}\r\n\r\n\tcommand(command, data) {\r\n\t\tcommand;\r\n\t\tdata;\r\n\t}\r\n}\r\n\r\n// Adds the protocol to SyncPlay statically, so every Client has it\r\nSyncPlay.Client.addStaticProtocol(new WebSocketProtocol());","window.SyncPlay = SyncPlay;"]}