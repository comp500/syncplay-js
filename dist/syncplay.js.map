{"version":3,"sources":["syncplay.js","index.js","ArrayHandlers.js","EventEmitter.js","Protocol.js","Player.js","Client.js","WebSocketProtocol.js","export.js"],"names":["SyncPlay","get","remove","index","callback","ArrayHandlers","fetchedProtocol","staticProtocolList","staticPlayerProxyList","command","data","window"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACTA;AACA;AACAA;ACFA;AACAC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEAC;AACA;AACA;AACAC;AACA;AACA;AACA;AACAA;AACA;AACA;AACA;AAzBA;AFuCA;AEXAH;AFaA;AACA;AGzCA;AAAA;AH4CA;AG3CA;AACA;AACA;AH6CA;AACA;AACA;AACA;AG7CA;AACA;AACA;AACA;AACA;AH+CA;AACA;AACA;AG/CA;AHiDA;AGhDA;AACAI;AACA;AACA;AACA;AACA;AHkDA;AACA;AACA;AGjDA;AACA;AHmDA;AACA;AACA;AGlDA;AACA;AHoDA;AGlDA;AACA;AACA;AHoDA;AGlDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AHoDA;AACA;AACA;AGnDA;AACA;AHqDA;AGnDA;AACA;AACA;AHqDA;AACA;AACA;AACA;AACA;AGtDAJ;ACpDA;AJ6GA;AACA;AACA;AACA;AI7GA;AAAA;AJgHA;AIhHA;AJkHA;AIhHA;AAFA;AAGA;AJmHA;AACA;AACA;AACA;AInHAA;AJqHA;AACA;AK9HA;ALgIA;AK/HA;AACA;ALiIA;AK9HAA;ACNA;ANuIA;AMrIA;AACA;ANuIA;AACA;AACA;AACA;AMvIA;AAAA;AN0IA;AM1IA;AN4IA;AM1IA;AACA;AACA;AACA;AALA;AAMA;AN6IA;AACA;AACA;AACA;AM7IA;AACA;AN+IA;AACA;AACA;AM9IA;AACA;ANgJA;AACA;AACA;AM/IAK;AACA;ANiJA;AACA;AACA;AMpIA;AACA;ANsIA;AACA;AACA;AMrIA;AACA;ANuIA;AACA;AACA;AMtIAA;AACA;ANwIA;AACA;AACA;AMvIA;AACA;ANyIA;AACA;AACA;AMxIA;AACA;AN0IA;AACA;AACA;AMzIAA;AACA;AN2IA;AACA;AACA;AM/HA;ANiIA;AMhIA;AACA;AACA;ANkIA;AMhIA;AACA;AACA;AACA;ANkIA;AMhIA;AACA;ANkIA;AMhIA;AACAC;AACAA;ANkIA;AMhIA;ANkIA;AMhIAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ANkIA;AACA;AACA;AMjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ANmIA;AACA;AACA;AMlIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ANoIA;AACA;AACA;AMnIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ANqIA;AACA;AACA;AMpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ANsIA;AMpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ANsIA;AACA;AACA;AM5QAC;AACA;AN8QA;AACA;AACA;AM7QA;AACA;AN+QA;AACA;AACA;AM9QAF;AACA;ANgRA;AACA;AACA;AMvPAG;AACA;ANyPA;AACA;AACA;AMxPA;AACA;AN0PA;AACA;AACA;AMzPAH;AACA;AN2PA;AACA;AACA;AACA;AACA;AMpKAL;ANsKA;AACA;AACA;AACA;AO3UA;AAAA;AP8UA;AO9UA;AAEA;AP+UA;AACA;AACA;AACA;AOhVA;APkVA;AOjVA;APmVA;AOjVA;AACAI;AACA;APmVA;AOjVA;AACA;AACA;AACA;APmVA;AACA;AACA;AOlVAK;AACAC;AACA;APoVA;AACA;AACA;AACA;AACA;AOrVA;APuVA;AACA;AOvVAV;ACxBAW","file":"syncplay.js","sourcesContent":[null,"/* eslint-disable no-unused-vars */\r\nlet SyncPlay = {};\r\nSyncPlay.util = {};","let ArrayHandlers = {\r\n\tget(array, content) {\r\n\t\tif (typeof content == \"string\") {\r\n\t\t\treturn array.find((itemFound) => {\r\n\t\t\t\treturn itemFound.name == content;\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\tif (array.includes(content)) {\r\n\t\t\t\treturn content;\r\n\t\t\t} else {\r\n\t\t\t\treturn undefined;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tremove(array, content) {\r\n\t\tlet index;\r\n\t\tif (typeof content == \"string\") {\r\n\t\t\tindex = array.findIndex((itemFound) => {\r\n\t\t\t\treturn itemFound.name == content;\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\tindex = array.indexOf(content);\r\n\t\t}\r\n\t\tif (index > -1) array.splice(index, 1);\r\n\t}\r\n};\r\n\r\nSyncPlay.util.ArrayHandlers = ArrayHandlers;","class EventEmitter {\r\n\tconstructor() {\r\n\t\tthis.eventList = {};\r\n\t\tthis.activeEvents = true;\r\n\t}\r\n\r\n\ton(name, callback) {\r\n\t\tif (this.eventList[name] == null) {\r\n\t\t\tthis.eventList[name] = [];\r\n\t\t}\r\n\t\tthis.eventList[name].push(callback);\r\n\t}\r\n\r\n\tonce(name, callback) {\r\n\t\tlet modifiedCallback = (data) => {\r\n\t\t\tcallback(data);\r\n\t\t\tthis.removeListener(name, modifiedCallback);\r\n\t\t};\r\n\t\tthis.on(name, modifiedCallback);\r\n\t}\r\n\r\n\tany(callback) {\r\n\t\tthis.on(\"*\", callback);\r\n\t}\r\n\r\n\temit(name, data) {\r\n\t\tif (!this.activeEvents) return 0;\r\n\t\tif (!this.eventList[name]) return 0;\r\n\t\t\r\n\t\tfor (let i = 0; i < this.eventList[name].length; i++) {\r\n\t\t\tthis.eventList[name](data);\r\n\t\t}\r\n\r\n\t\tif (this.eventList[\"*\"] && this.eventList[\"*\"].length > 0) {\r\n\t\t\tfor (let i = 0; i < this.eventList[\"*\"].length; i++) {\r\n\t\t\t\tthis.eventList[\"*\"](data);\r\n\t\t\t}\r\n\t\t\treturn this.eventList[name].length + this.eventList[\"*\"].length;\r\n\t\t} else {\r\n\t\t\treturn this.eventList[name].length;\r\n\t\t}\r\n\t}\r\n\r\n\tremoveListener(name, callback) {\r\n\t\t// TODO: find a way to gracefully report problems like this\r\n\t\tif (!this.eventList[name]) return;\r\n\r\n\t\tlet index = this.eventList[name].indexOf(callback);\r\n\t\tif (index > -1) this.eventList.splice(index, 1);\r\n\t}\r\n}\r\n\r\nSyncPlay.util.EventEmitter = EventEmitter;","/* global EventEmitter */\r\n\r\nclass Protocol extends EventEmitter {\r\n\tconstructor(name) {\r\n\t\tsuper();\r\n\t\tthis.name = name;\r\n\t}\r\n}\r\n\r\nSyncPlay.Protocol = Protocol;","class Player {\r\n\tconstructor(name) {\r\n\t\tthis.name = name;\r\n\t}\r\n}\r\n\r\nSyncPlay.Player = Player;","/* global EventEmitter, ArrayHandlers */\r\n\r\nlet staticProtocolList = [];\r\nlet staticPlayerProxyList = [];\r\n\r\nclass Client extends EventEmitter {\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.protocolList = staticProtocolList;\r\n\t\tthis.playerList = [];\r\n\t\tthis.playerProxyList = staticPlayerProxyList;\r\n\t\tthis.state = 0;\r\n\t}\r\n\r\n\taddProtocol(protocol) {\r\n\t\tthis.protocolList.push(protocol);\r\n\t}\r\n\r\n\tgetProtocol(protocol) {\r\n\t\treturn ArrayHandlers.get(this.protocolList, protocol);\r\n\t}\r\n\r\n\tremoveProtocol(protocol) {\r\n\t\tArrayHandlers.remove(this.protocolList, protocol);\r\n\t}\r\n\r\n\tstatic addStaticProtocol(protocol) {\r\n\t\tstaticProtocolList.push(protocol);\r\n\t}\r\n\r\n\tstatic getStaticProtocol(protocol) {\r\n\t\treturn ArrayHandlers.get(staticProtocolList, protocol);\r\n\t}\r\n\r\n\tstatic removeStaticProtocol(protocol) {\r\n\t\tArrayHandlers.remove(staticProtocolList, protocol);\r\n\t}\r\n\r\n\taddPlayer(player) {\r\n\t\tthis.playerList.push(player);\r\n\t}\r\n\r\n\tgetPlayer(player) {\r\n\t\treturn ArrayHandlers.get(this.playerList, player);\r\n\t}\r\n\r\n\tremovePlayer(player) {\r\n\t\tArrayHandlers.remove(this.playerList, player);\r\n\t}\r\n\r\n\taddPlayerProxy(playerProxy) {\r\n\t\tthis.playerProxyList.push(playerProxy);\r\n\t}\r\n\r\n\tgetPlayerProxy(playerProxy) {\r\n\t\treturn ArrayHandlers.get(this.playerProxyList, playerProxy);\r\n\t}\r\n\r\n\tremovePlayerProxy(playerProxy) {\r\n\t\tArrayHandlers.remove(this.playerProxyList, playerProxy);\r\n\t}\r\n\r\n\tstatic addStaticPlayerProxy(playerProxy) {\r\n\t\tstaticPlayerProxyList.push(playerProxy);\r\n\t}\r\n\r\n\tstatic getStaticPlayerProxy(playerProxy) {\r\n\t\treturn ArrayHandlers.get(staticPlayerProxyList, playerProxy);\r\n\t}\r\n\r\n\tstatic removeStaticPlayerProxy(playerProxy) {\r\n\t\tArrayHandlers.remove(staticPlayerProxyList, playerProxy);\r\n\t}\r\n\r\n\tconnect(protocol, options) {\r\n\t\tif (this.state != 0) {\r\n\t\t\tthrow new Error(\"Client is currently connected, must disconnect first before reconnecting.\");\r\n\t\t}\r\n\r\n\t\tlet fetchedProtocol = this.getProtocol(protocol);\r\n\t\tif (fetchedProtocol == undefined || !fetchedProtocol) {\r\n\t\t\tthrow new Error(\"No protocol of that name is loaded!\");\r\n\t\t}\r\n\r\n\t\tthis.currentProtocol = fetchedProtocol;\r\n\t\tthis.state = 1;\r\n\r\n\t\tthis.proxyEvents(\"connecting\", protocol);\r\n\t\tfetchedProtocol.any(this.proxyEvents);\r\n\t\tfetchedProtocol.on(\"seturl\", this.setURL);\r\n\r\n\t\t// TODO: implement some sort of log system, for errors, connection progress etc.\r\n\r\n\t\tfetchedProtocol.connect(options, () => {\r\n\t\t\tif (this.state != 1) {\r\n\t\t\t\treturn; // ignore event if not in connecting state\r\n\t\t\t}\r\n\t\t\tthis.state = 2;\r\n\t\t\tthis.proxyEvents(\"connected\");\r\n\t\t});\r\n\t}\r\n\r\n\tproxyEvents(event, data) {\r\n\t\tfor (let i = 0; i < this.playerProxyList; i++) {\r\n\t\t\tthis.playerProxyList[i].on(event, data);\r\n\t\t}\r\n\t\tif (this.currentPlayer) {\r\n\t\t\t// players must not respond to seturl\r\n\t\t\tthis.currentPlayer.on(event, data);\r\n\t\t}\r\n\t}\r\n\r\n\tproxyCommand(command, data) {\r\n\t\tif (this.currentPlayer) {\r\n\t\t\tfor (let i = 0; i < this.playerProxyList; i++) {\r\n\t\t\t\tthis.playerProxyList[i].command(command, data);\r\n\t\t\t}\r\n\t\t\tthis.currentPlayer.command(command, data);\r\n\t\t} else {\r\n\t\t\t// TODO: maybe error if problematic?\r\n\t\t}\r\n\t}\r\n\r\n\tproxyCommandToProtocol(command, data) {\r\n\t\t// TODO: Should players emit (and have proxied) events?\r\n\t\tif (this.currentPlayer) {\r\n\t\t\tfor (let i = 0; i < this.playerProxyList; i++) {\r\n\t\t\t\tthis.playerProxyList[i].command(command, data);\r\n\t\t\t}\r\n\t\t\tthis.currentProtocol.command(command, data);\r\n\t\t} else {\r\n\t\t\t// TODO: maybe error if problematic?\r\n\t\t}\r\n\t}\r\n\r\n\tsetURL(url) {\r\n\t\tif (this.currentPlayer) {\r\n\t\t\t// TODO: what happens when a http player\r\n\t\t\t//       and yt player coexist? how do\r\n\t\t\t//       we choose which to use?\r\n\t\t\tif (this.currentPlayer.supports(url)) {\r\n\t\t\t\tthis.proxyCommand(\"seturl\", url);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet foundPlayer = this.playerList.find((player) => {\r\n\t\t\treturn player.supports(url);\r\n\t\t});\r\n\t\tif (foundPlayer) {\r\n\t\t\t// if player is found, switch to it\r\n\t\t\tthis.currentPlayer.command(\"terminate\");\r\n\t\t\tthis.currentPlayer = foundPlayer;\r\n\t\t\tthis.proxyCommand(\"seturl\", url);\r\n\t\t} else {\r\n\t\t\t// TODO: handle no players to play url\r\n\t\t\t//       catch-all player?\r\n\t\t\tthrow new Error(\"No players to handle URL available\");\r\n\t\t}\r\n\t}\r\n\t\r\n}\r\n\r\nSyncPlay.Client = Client;","class WebSocketProtocol extends SyncPlay.Protocol {\r\n\tconstructor() {\r\n\t\tsuper(\"WebSocket-builtin\");\r\n\t}\r\n\r\n\tconnect(options, callback) {\r\n\t\tthis.socket = new WebSocket(options.url);\r\n\r\n\t\tthis.socket.addEventListener(\"open\", () => {\r\n\t\t\tcallback();\r\n\t\t});\r\n\r\n\t\tthis.socket.addEventListener(\"message\", (data) => {\r\n\t\t\tthis.emit(\"message\", data);\r\n\t\t});\r\n\t}\r\n\r\n\tcommand(command, data) {\r\n\t\tcommand;\r\n\t\tdata;\r\n\t}\r\n}\r\n\r\n// Adds the protocol to SyncPlay statically, so every Client has it\r\nSyncPlay.Client.addStaticProtocol(new WebSocketProtocol());","window.SyncPlay = SyncPlay;"]}